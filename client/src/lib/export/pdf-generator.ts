import html2canvas from 'html2canvas'
import jsPDF from 'jspdf'
import { Character } from '@/lib/api/schemas'
import { GraphData } from '@/lib/graph/co-occurrence'
import { NetworkMetrics, NetworkStats } from '@/lib/analysis/network-metrics'
import { EnhancedQuote } from '@/lib/analysis/enhanced-sentiment'
import { ChapterTopic } from '@/lib/analysis/topic-analysis'

export interface ReportData {
  bookTitle: string
  bookAuthor: string
  bookId: string
  analysisDate: Date
  characters: Character[]
  graphData: GraphData
  networkMetrics: NetworkMetrics[]
  networkStats: NetworkStats
  quotes: EnhancedQuote[]
  chapterTopics: ChapterTopic[]
  processingTime: number
  extractionMethod: string
  totalWords: number
}

export interface ReportOptions {
  includeGraphImage: boolean
  includeTimelines: boolean
  includeQuotes: boolean
  includeTopics: boolean
  includeMetrics: boolean
  maxQuotes: number
  format: 'a4' | 'letter'
  orientation: 'portrait' | 'landscape'
  quality: 'standard' | 'high'
}

export class PDFReportGenerator {
  private doc: jsPDF
  private currentY: number = 20
  private pageWidth: number
  private pageHeight: number
  private margin: number = 20
  private lineHeight: number = 7
  private options: ReportOptions

  constructor(options: Partial<ReportOptions> = {}) {
    this.options = {
      includeGraphImage: true,
      includeTimelines: true,
      includeQuotes: true,
      includeTopics: true,
      includeMetrics: true,
      maxQuotes: 10,
      format: 'a4',
      orientation: 'portrait',
      quality: 'high',
      ...options
    }

    this.doc = new jsPDF({
      orientation: this.options.orientation,
      unit: 'mm',
      format: this.options.format
    })

    this.pageWidth = this.doc.internal.pageSize.getWidth()
    this.pageHeight = this.doc.internal.pageSize.getHeight()
  }

  /**
   * Generate complete PDF report
   */
  async generateReport(data: ReportData, onProgress?: (progress: number) => void): Promise<void> {
    try {
      onProgress?.(10)
      
      // Title page
      this.addTitlePage(data)
      onProgress?.(20)

      // Executive summary
      this.addExecutiveSummary(data)
      onProgress?.(30)

      // Character analysis
      this.addCharacterAnalysis(data)
      onProgress?.(40)

      // Network metrics
      if (this.options.includeMetrics) {
        this.addNetworkMetrics(data)
      }
      onProgress?.(50)

      // Graph visualization
      if (this.options.includeGraphImage) {
        await this.addGraphVisualization()
      }
      onProgress?.(70)

      // Character quotes
      if (this.options.includeQuotes && data.quotes.length > 0) {
        this.addCharacterQuotes(data)
      }
      onProgress?.(80)

      // Topic analysis
      if (this.options.includeTopics && data.chapterTopics.length > 0) {
        this.addTopicAnalysis(data)
      }
      onProgress?.(90)

      // Appendix
      this.addAppendix(data)
      onProgress?.(100)

    } catch (error) {
      console.error('PDF generation failed:', error)
      throw new Error('Failed to generate PDF report')
    }
  }

  /**
   * Save the PDF with a filename
   */
  save(filename?: string): void {
    const name = filename || `gutenberg-analysis-${Date.now()}.pdf`
    this.doc.save(name)
  }

  /**
   * Get PDF as blob
   */
  getBlob(): Blob {
    return this.doc.output('blob')
  }

  /**
   * Add title page
   */
  private addTitlePage(data: ReportData): void {
    // Title
    this.doc.setFontSize(24)
    this.doc.setTextColor(75, 85, 150) // Primary color
    this.doc.text('Character Network Analysis', this.pageWidth / 2, 40, { align: 'center' })

    // Subtitle
    this.doc.setFontSize(16)
    this.doc.setTextColor(100, 100, 100)
    this.doc.text('Gutenberg Project Literary Insights', this.pageWidth / 2, 55, { align: 'center' })

    // Book information
    this.doc.setFontSize(14)
    this.doc.setTextColor(0, 0, 0)
    this.doc.text(`Book: ${data.bookTitle}`, this.pageWidth / 2, 80, { align: 'center' })
    this.doc.text(`Author: ${data.bookAuthor}`, this.pageWidth / 2, 90, { align: 'center' })
    this.doc.text(`Book ID: ${data.bookId}`, this.pageWidth / 2, 100, { align: 'center' })

    // Analysis date
    this.doc.setFontSize(10)
    this.doc.setTextColor(100, 100, 100)
    this.doc.text(`Analysis Date: ${data.analysisDate.toLocaleDateString()}`, this.pageWidth / 2, 120, { align: 'center' })

    // Decorative line
    this.doc.setDrawColor(75, 85, 150)
    this.doc.setLineWidth(0.5)
    this.doc.line(this.margin, 140, this.pageWidth - this.margin, 140)

    // Generation info
    this.doc.setFontSize(8)
    this.doc.text('Generated by Gutenberg Character Analysis Tool', this.pageWidth / 2, 160, { align: 'center' })
    this.doc.text('https://gutenberg-insights.app', this.pageWidth / 2, 170, { align: 'center' })

    this.addNewPage()
  }

  /**
   * Add executive summary
   */
  private addExecutiveSummary(data: ReportData): void {
    this.addSectionHeader('Executive Summary')

    // Key statistics
    const stats = [
      `Total Characters Identified: ${data.characters.length}`,
      `Network Connections: ${data.graphData.edges.length}`,
      `Network Density: ${(data.networkStats.density * 100).toFixed(1)}%`,
      `Average Degree: ${data.networkStats.averageDegree.toFixed(1)}`,
      `Text Length: ${data.totalWords.toLocaleString()} words`,
      `Processing Time: ${(data.processingTime / 1000).toFixed(1)} seconds`,
      `Extraction Method: ${data.extractionMethod.toUpperCase()}`
    ]

    stats.forEach(stat => {
      this.addText(stat)
    })

    // Top characters
    this.addSubheader('Most Important Characters')
    const topCharacters = data.characters
      .sort((a, b) => b.importance - a.importance)
      .slice(0, 5)

    topCharacters.forEach((char, index) => {
      this.addText(`${index + 1}. ${char.name} (${char.mentions} mentions, importance: ${char.importance})`)
    })

    // Network insights
    this.addSubheader('Network Structure')
    this.addText(`This analysis reveals a ${data.networkStats.density > 0.3 ? 'highly connected' : 'moderately connected'} character network.`)
    this.addText(`The network contains ${data.networkStats.components} connected component${data.networkStats.components !== 1 ? 's' : ''}.`)
    
    if (data.networkStats.modularity > 0.3) {
      this.addText(`High modularity (${data.networkStats.modularity.toFixed(3)}) suggests distinct character communities.`)
    }

    this.addNewPage()
  }

  /**
   * Add character analysis section
   */
  private addCharacterAnalysis(data: ReportData): void {
    this.addSectionHeader('Character Analysis')

    // Character table
    this.addSubheader('Character Overview')
    
    const tableY = this.currentY
    const colWidth = (this.pageWidth - 2 * this.margin) / 4
    
    // Table headers
    this.doc.setFontSize(8)
    this.doc.setFont('helvetica', 'bold')
    this.doc.text('Character Name', this.margin, tableY)
    this.doc.text('Mentions', this.margin + colWidth, tableY)
    this.doc.text('Importance', this.margin + 2 * colWidth, tableY)
    this.doc.text('Centrality', this.margin + 3 * colWidth, tableY)

    // Table data
    this.doc.setFont('helvetica', 'normal')
    let rowY = tableY + 7

    data.characters.slice(0, 20).forEach((char, index) => {
      if (rowY > this.pageHeight - 30) {
        this.addNewPage()
        rowY = this.currentY
      }

      const metrics = data.networkMetrics.find(m => m.nodeId === char.name)

      this.doc.text(char.name.length > 20 ? char.name.substring(0, 17) + '...' : char.name, this.margin, rowY)
      this.doc.text(char.mentions.toString(), this.margin + colWidth, rowY)
      this.doc.text(char.importance.toString(), this.margin + 2 * colWidth, rowY)
      this.doc.text(metrics ? metrics.pageRank.toFixed(3) : 'N/A', this.margin + 3 * colWidth, rowY)

      rowY += 5
    })

    this.currentY = rowY + 10
  }

  /**
   * Add network metrics section
   */
  private addNetworkMetrics(data: ReportData): void {
    this.addSectionHeader('Network Metrics')

    // Global metrics
    this.addSubheader('Global Network Statistics')
    
    const globalMetrics = [
      `Nodes: ${data.graphData.nodes.length}`,
      `Edges: ${data.graphData.edges.length}`,
      `Density: ${(data.networkStats.density * 100).toFixed(2)}%`,
      `Average Degree: ${data.networkStats.averageDegree.toFixed(2)}`,
      `Connected Components: ${data.networkStats.components}`,
      `Modularity: ${data.networkStats.modularity.toFixed(3)}`,
      `Network Diameter: ${data.networkStats.diameter}`,
      `Average Clustering: ${data.networkStats.clustering.toFixed(3)}`
    ]

    globalMetrics.forEach(metric => {
      this.addText(metric)
    })

    // Top centrality characters
    this.addSubheader('Centrality Rankings')
    
    const topCentrality = data.networkMetrics
      .sort((a, b) => b.betweennessCentrality - a.betweennessCentrality)
      .slice(0, 10)

    topCentrality.forEach((metric, index) => {
      this.addText(`${index + 1}. ${metric.nodeId} - Betweenness: ${metric.betweennessCentrality.toFixed(3)}`)
    })
  }

  /**
   * Add graph visualization
   */
  private async addGraphVisualization(): Promise<void> {
    this.addSectionHeader('Network Visualization')

    try {
      // Find the graph container
      const graphContainer = document.querySelector('.force-graph-container, [class*="force-graph"]') as HTMLElement
      
      if (!graphContainer) {
        this.addText('Graph visualization not available for capture.')
        return
      }

      // Capture graph as image
      const canvas = await html2canvas(graphContainer, {
        backgroundColor: '#ffffff',
        scale: this.options.quality === 'high' ? 2 : 1,
        logging: false,
        useCORS: true
      })

      // Calculate dimensions to fit on page
      const maxWidth = this.pageWidth - 2 * this.margin
      const maxHeight = (this.pageHeight - this.currentY - this.margin) * 0.8
      
      let imgWidth = maxWidth
      let imgHeight = (canvas.height / canvas.width) * maxWidth

      if (imgHeight > maxHeight) {
        imgHeight = maxHeight
        imgWidth = (canvas.width / canvas.height) * maxHeight
      }

      // Add image to PDF
      const imgData = canvas.toDataURL('image/jpeg', 0.8)
      this.doc.addImage(imgData, 'JPEG', this.margin, this.currentY, imgWidth, imgHeight)
      
      this.currentY += imgHeight + 10

    } catch (error) {
      console.error('Failed to capture graph:', error)
      this.addText('Unable to capture graph visualization.')
    }
  }

  /**
   * Add character quotes section
   */
  private addCharacterQuotes(data: ReportData): void {
    this.addSectionHeader('Character Quotes & Sentiment')

    const topQuotes = data.quotes
      .sort((a, b) => Math.abs(b.sentiment) - Math.abs(a.sentiment))
      .slice(0, this.options.maxQuotes)

    topQuotes.forEach((quote, index) => {
      this.addSubheader(`Quote ${index + 1} - ${quote.character}`)
      
      // Quote text
      this.doc.setFontSize(9)
      this.doc.setFont('helvetica', 'italic')
      const quoteLines = this.doc.splitTextToSize(`"${quote.text}"`, this.pageWidth - 2 * this.margin - 10)
      this.doc.text(quoteLines, this.margin + 5, this.currentY)
      this.currentY += quoteLines.length * this.lineHeight

      // Sentiment info
      this.doc.setFont('helvetica', 'normal')
      this.doc.setFontSize(8)
      const sentimentColor = quote.sentiment > 0 ? [0, 150, 0] : quote.sentiment < 0 ? [150, 0, 0] : [100, 100, 100]
      this.doc.setTextColor(...sentimentColor)
      this.addText(`Sentiment: ${quote.sentiment.toFixed(2)} | Confidence: ${quote.confidence.toFixed(2)} | Chapter: ${quote.chapter}`)
      this.doc.setTextColor(0, 0, 0)
      
      this.currentY += 5
    })
  }

  /**
   * Add topic analysis section
   */
  private addTopicAnalysis(data: ReportData): void {
    this.addSectionHeader('Topic Analysis')

    this.addSubheader('Key Topics by Chapter')

    data.chapterTopics.slice(0, 10).forEach(topic => {
      this.addText(`Chapter ${topic.chapter}: ${topic.keywords.slice(0, 5).join(', ')}`)
    })

    // Most frequent topics
    this.addSubheader('Most Frequent Topics')
    
    const allKeywords = data.chapterTopics.flatMap(topic => topic.keywords)
    const keywordFreq = new Map<string, number>()
    
    allKeywords.forEach(keyword => {
      keywordFreq.set(keyword, (keywordFreq.get(keyword) || 0) + 1)
    })

    const topKeywords = Array.from(keywordFreq.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 20)

    topKeywords.forEach(([keyword, freq], index) => {
      this.addText(`${index + 1}. ${keyword} (${freq} chapters)`)
    })
  }

  /**
   * Add appendix
   */
  private addAppendix(data: ReportData): void {
    this.addSectionHeader('Technical Appendix')

    this.addSubheader('Analysis Parameters')
    this.addText(`Character Extraction Method: ${data.extractionMethod}`)
    this.addText(`Network Analysis: Co-occurrence within sentence windows`)
    this.addText(`Sentiment Analysis: AFINN lexicon with negation handling`)
    this.addText(`Topic Analysis: TF-IDF with stopword filtering`)

    this.addSubheader('Data Sources')
    this.addText(`Book Source: Project Gutenberg (gutenberg.org)`)
    this.addText(`Book ID: ${data.bookId}`)
    this.addText(`Analysis Date: ${data.analysisDate.toISOString()}`)

    this.addSubheader('Methodology')
    this.addText('This analysis uses computational methods to identify character relationships and narrative patterns.')
    this.addText('Network metrics provide quantitative insights into character importance and story structure.')
    this.addText('Sentiment analysis reveals emotional patterns associated with different characters.')
  }

  /**
   * Helper methods
   */
  private addSectionHeader(title: string): void {
    if (this.currentY > 50) {
      this.addNewPage()
    }

    this.doc.setFontSize(16)
    this.doc.setFont('helvetica', 'bold')
    this.doc.setTextColor(75, 85, 150)
    this.doc.text(title, this.margin, this.currentY)
    this.currentY += 10

    // Underline
    this.doc.setDrawColor(75, 85, 150)
    this.doc.setLineWidth(0.5)
    this.doc.line(this.margin, this.currentY - 5, this.margin + this.doc.getTextWidth(title), this.currentY - 5)
    
    this.currentY += 5
    this.doc.setTextColor(0, 0, 0)
  }

  private addSubheader(title: string): void {
    this.checkPageBreak(15)
    
    this.doc.setFontSize(12)
    this.doc.setFont('helvetica', 'bold')
    this.doc.text(title, this.margin, this.currentY)
    this.currentY += 8
    this.doc.setFont('helvetica', 'normal')
  }

  private addText(text: string): void {
    this.checkPageBreak(10)
    
    this.doc.setFontSize(9)
    const lines = this.doc.splitTextToSize(text, this.pageWidth - 2 * this.margin)
    this.doc.text(lines, this.margin, this.currentY)
    this.currentY += lines.length * this.lineHeight
  }

  private checkPageBreak(requiredSpace: number): void {
    if (this.currentY + requiredSpace > this.pageHeight - this.margin) {
      this.addNewPage()
    }
  }

  private addNewPage(): void {
    this.doc.addPage()
    this.currentY = this.margin
    this.addPageNumber()
  }

  private addPageNumber(): void {
    const pageNum = this.doc.getNumberOfPages()
    this.doc.setFontSize(8)
    this.doc.setTextColor(100, 100, 100)
    this.doc.text(`Page ${pageNum}`, this.pageWidth - this.margin, this.pageHeight - 10, { align: 'right' })
    this.doc.setTextColor(0, 0, 0)
  }
}

/**
 * Utility function to generate report from analysis context
 */
export async function generatePDFReport(
  analysisData: any,
  options: Partial<ReportOptions> = {},
  onProgress?: (progress: number) => void
): Promise<void> {
  const reportData: ReportData = {
    bookTitle: analysisData.bookTitle || 'Unknown Book',
    bookAuthor: analysisData.bookAuthor || 'Unknown Author',
    bookId: analysisData.bookId || '0',
    analysisDate: new Date(),
    characters: analysisData.characters || [],
    graphData: analysisData.graphData || { nodes: [], edges: [] },
    networkMetrics: analysisData.networkMetrics || [],
    networkStats: analysisData.networkStats || {
      density: 0,
      averageDegree: 0,
      components: 1,
      modularity: 0,
      diameter: 0,
      clustering: 0
    },
    quotes: analysisData.enhancedQuotes || [],
    chapterTopics: analysisData.chapterTopics || [],
    processingTime: analysisData.stats?.processingTime || 0,
    extractionMethod: analysisData.stats?.extractionMethod || 'manual',
    totalWords: analysisData.stats?.textLength || 0
  }

  const generator = new PDFReportGenerator(options)
  await generator.generateReport(reportData, onProgress)
  
  const filename = `${reportData.bookTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_analysis_report.pdf`
  generator.save(filename)
}
