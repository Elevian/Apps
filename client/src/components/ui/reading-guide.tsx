import React, { useState, useCallback, useMemo } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Separator } from '@/components/ui/separator'
import { Switch } from '@/components/ui/switch'
import { 
  BookOpen,
  Copy,
  Download,
  Sparkles,
  ChevronDown,
  ChevronRight,
  Clock,
  Hash,
  Brain,
  Zap,
  RefreshCw,
  CheckCircle2
} from 'lucide-react'
import { ChapterTopic } from '@/lib/analysis/topic-analysis'
import { toast } from 'sonner'

export interface ChapterSummary {
  chapterNumber: number
  title?: string
  summary: string
  keyTopics: string[]
  sentiment: 'positive' | 'negative' | 'neutral'
  wordCount: number
  readingTime: number // minutes
  generationMethod: 'ollama' | 'tfidf' | 'manual'
  confidence: number
}

export interface ReadingGuideProps {
  bookTitle?: string
  bookAuthor?: string
  bookText?: string
  chapterTopics?: ChapterTopic[]
  totalChapters?: number
  onSummaryGenerated?: (summaries: ChapterSummary[]) => void
  className?: string
}

export function ReadingGuide({
  bookTitle,
  bookAuthor,
  bookText,
  chapterTopics = [],
  totalChapters = 0,
  onSummaryGenerated,
  className
}: ReadingGuideProps) {
  
  // Component state
  const [summaries, setSummaries] = useState<ChapterSummary[]>([])
  const [isGenerating, setIsGenerating] = useState(false)
  const [expandedChapters, setExpandedChapters] = useState<Set<number>>(new Set())
  const [useOllama, setUseOllama] = useState(true)
  const [generationProgress, setGenerationProgress] = useState(0)
  const [currentChapter, setCurrentChapter] = useState(0)
  const [isOllamaAvailable, setIsOllamaAvailable] = useState(false)

  // Check Ollama availability on mount
  React.useEffect(() => {
    checkOllamaAvailability()
  }, [])

  // Generate all summaries
  const generateSummaries = useCallback(async () => {
    if (!bookText || totalChapters === 0) {
      toast.error('No book text available for summarization')
      return
    }

    setIsGenerating(true)
    setGenerationProgress(0)
    setCurrentChapter(0)

    try {
      const chapters = splitTextIntoChapters(bookText)
      const newSummaries: ChapterSummary[] = []

      for (let i = 0; i < chapters.length; i++) {
        setCurrentChapter(i + 1)
        setGenerationProgress(((i + 1) / chapters.length) * 100)

        const chapter = chapters[i]
        let summary: ChapterSummary

        if (useOllama && isOllamaAvailable) {
          // Try Ollama first
          try {
            summary = await generateOllamaSummary(chapter, i + 1)
          } catch (error) {
            console.warn('Ollama failed, falling back to TF-IDF:', error)
            summary = generateTFIDFSummary(chapter, i + 1, chapterTopics)
          }
        } else {
          // Use TF-IDF method
          summary = generateTFIDFSummary(chapter, i + 1, chapterTopics)
        }

        newSummaries.push(summary)
        
        // Small delay to prevent overwhelming the UI
        await new Promise(resolve => setTimeout(resolve, 100))
      }

      setSummaries(newSummaries)
      onSummaryGenerated?.(newSummaries)
      toast.success(`Generated ${newSummaries.length} chapter summaries!`)
      
    } catch (error) {
      console.error('Summary generation failed:', error)
      toast.error('Failed to generate summaries')
    } finally {
      setIsGenerating(false)
      setGenerationProgress(0)
      setCurrentChapter(0)
    }
  }, [bookText, totalChapters, useOllama, isOllamaAvailable, chapterTopics, onSummaryGenerated])

  // Toggle chapter expansion
  const toggleChapter = useCallback((chapterNumber: number) => {
    setExpandedChapters(prev => {
      const newSet = new Set(prev)
      if (newSet.has(chapterNumber)) {
        newSet.delete(chapterNumber)
      } else {
        newSet.add(chapterNumber)
      }
      return newSet
    })
  }, [])

  // Copy all summaries
  const copyAllSummaries = useCallback(() => {
    if (summaries.length === 0) return

    const allSummariesText = summaries.map(summary => 
      `Chapter ${summary.chapterNumber}${summary.title ? `: ${summary.title}` : ''}\n${summary.summary}\n\nKey Topics: ${summary.keyTopics.join(', ')}\nReading Time: ~${summary.readingTime} minutes\n`
    ).join('\n---\n\n')

    const fullText = `${bookTitle ? `${bookTitle}` : 'Book'} ${bookAuthor ? `by ${bookAuthor}` : ''}\nChapter Summaries\n\n${allSummariesText}\n\nGenerated by Gutenberg Character Analysis`

    navigator.clipboard.writeText(fullText).then(() => {
      toast.success('All summaries copied to clipboard!')
    }).catch(() => {
      toast.error('Failed to copy to clipboard')
    })
  }, [summaries, bookTitle, bookAuthor])

  // Export summaries
  const exportSummaries = useCallback(() => {
    if (summaries.length === 0) return

    const exportData = {
      book: {
        title: bookTitle,
        author: bookAuthor,
        totalChapters: summaries.length
      },
      summaries: summaries.map(s => ({
        chapter: s.chapterNumber,
        title: s.title,
        summary: s.summary,
        keyTopics: s.keyTopics,
        sentiment: s.sentiment,
        wordCount: s.wordCount,
        readingTime: s.readingTime,
        generationMethod: s.generationMethod,
        confidence: s.confidence
      })),
      metadata: {
        generatedAt: new Date().toISOString(),
        totalReadingTime: summaries.reduce((sum, s) => sum + s.readingTime, 0),
        averageConfidence: summaries.reduce((sum, s) => sum + s.confidence, 0) / summaries.length
      }
    }

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = `${bookTitle?.replace(/\s+/g, '-').toLowerCase() || 'book'}-summaries.json`
    link.click()
    URL.revokeObjectURL(url)
    toast.success('Summaries exported!')
  }, [summaries, bookTitle, bookAuthor])

  // Statistics
  const stats = useMemo(() => {
    if (summaries.length === 0) return null

    const totalReadingTime = summaries.reduce((sum, s) => sum + s.readingTime, 0)
    const averageConfidence = summaries.reduce((sum, s) => sum + s.confidence, 0) / summaries.length
    const sentimentCounts = summaries.reduce((acc, s) => {
      acc[s.sentiment]++
      return acc
    }, { positive: 0, neutral: 0, negative: 0 })

    return {
      totalReadingTime,
      averageConfidence,
      sentimentCounts,
      ollamaGenerated: summaries.filter(s => s.generationMethod === 'ollama').length,
      tfidfGenerated: summaries.filter(s => s.generationMethod === 'tfidf').length
    }
  }, [summaries])

  return (
    <div className={className}>
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <BookOpen className="h-5 w-5" />
              Reading Guide
              {summaries.length > 0 && (
                <Badge variant="secondary">
                  {summaries.length} chapters
                </Badge>
              )}
            </div>
            <div className="flex items-center gap-2">
              {summaries.length > 0 && (
                <>
                  <Button variant="outline" size="sm" onClick={exportSummaries}>
                    <Download className="h-3 w-3 mr-1" />
                    Export
                  </Button>
                  <Button variant="outline" size="sm" onClick={copyAllSummaries}>
                    <Copy className="h-3 w-3 mr-1" />
                    Copy All
                  </Button>
                </>
              )}
              <Button
                onClick={generateSummaries}
                disabled={isGenerating || !bookText}
              >
                {isGenerating ? (
                  <RefreshCw className="h-3 w-3 mr-1 animate-spin" />
                ) : (
                  <Sparkles className="h-3 w-3 mr-1" />
                )}
                Generate Summaries
              </Button>
            </div>
          </CardTitle>
        </CardHeader>

        <CardContent className="space-y-6">
          
          {/* Book Info */}
          {(bookTitle || bookAuthor) && (
            <div className="p-3 bg-muted/50 rounded-lg">
              <h4 className="font-medium">{bookTitle || 'Unknown Title'}</h4>
              {bookAuthor && (
                <p className="text-sm text-muted-foreground">by {bookAuthor}</p>
              )}
              {totalChapters > 0 && (
                <p className="text-xs text-muted-foreground mt-1">
                  {totalChapters} chapters available for summarization
                </p>
              )}
            </div>
          )}

          {/* Generation Settings */}
          <div className="space-y-3">
            <h4 className="font-medium text-sm">Generation Settings</h4>
            <div className="flex items-center justify-between p-3 border rounded-lg">
              <div className="space-y-1">
                <div className="flex items-center gap-2">
                  <Switch
                    checked={useOllama}
                    onCheckedChange={setUseOllama}
                    disabled={!isOllamaAvailable}
                  />
                  <span className="text-sm">Use Ollama LLM</span>
                  {isOllamaAvailable ? (
                    <Badge variant="outline" className="text-green-600">
                      <CheckCircle2 className="h-3 w-3 mr-1" />
                      Available
                    </Badge>
                  ) : (
                    <Badge variant="outline" className="text-orange-600">
                      Offline
                    </Badge>
                  )}
                </div>
                <p className="text-xs text-muted-foreground">
                  {useOllama && isOllamaAvailable
                    ? 'High-quality AI summaries with fallback to keyword analysis'
                    : 'TF-IDF keyword-based summaries (faster, lower quality)'
                  }
                </p>
              </div>
              <Brain className="h-5 w-5 text-muted-foreground" />
            </div>
          </div>

          {/* Generation Progress */}
          {isGenerating && (
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <span className="text-sm font-medium">
                  Generating chapter summaries...
                </span>
                <span className="text-sm text-muted-foreground">
                  Chapter {currentChapter} of {totalChapters}
                </span>
              </div>
              <div className="w-full bg-muted rounded-full h-2">
                <div
                  className="bg-primary h-2 rounded-full transition-all duration-300"
                  style={{ width: `${generationProgress}%` }}
                />
              </div>
              <p className="text-xs text-muted-foreground">
                Using {useOllama && isOllamaAvailable ? 'Ollama LLM' : 'TF-IDF'} method
              </p>
            </div>
          )}

          {/* Statistics */}
          {stats && (
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="text-center p-3 rounded-lg bg-muted/50">
                <p className="text-lg font-bold text-primary">{summaries.length}</p>
                <p className="text-xs text-muted-foreground">Chapters</p>
              </div>
              <div className="text-center p-3 rounded-lg bg-muted/50">
                <p className="text-lg font-bold text-primary">{stats.totalReadingTime}m</p>
                <p className="text-xs text-muted-foreground">Reading Time</p>
              </div>
              <div className="text-center p-3 rounded-lg bg-muted/50">
                <p className="text-lg font-bold text-primary">{(stats.averageConfidence * 100).toFixed(0)}%</p>
                <p className="text-xs text-muted-foreground">Avg Confidence</p>
              </div>
              <div className="text-center p-3 rounded-lg bg-muted/50">
                <p className="text-lg font-bold text-primary">{stats.ollamaGenerated}</p>
                <p className="text-xs text-muted-foreground">AI Generated</p>
              </div>
            </div>
          )}

          {/* Chapter Summaries */}
          {summaries.length > 0 && (
            <div className="space-y-3">
              <div className="flex items-center justify-between">
                <h4 className="font-medium">Chapter Summaries</h4>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setExpandedChapters(new Set(summaries.map(s => s.chapterNumber)))}
                  >
                    Expand All
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setExpandedChapters(new Set())}
                  >
                    Collapse All
                  </Button>
                </div>
              </div>

              <div className="space-y-2">
                {summaries.map((summary, index) => (
                  <motion.div
                    key={summary.chapterNumber}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: index * 0.05 }}
                  >
                    <ChapterSummaryCard
                      summary={summary}
                      isExpanded={expandedChapters.has(summary.chapterNumber)}
                      onToggle={() => toggleChapter(summary.chapterNumber)}
                    />
                  </motion.div>
                ))}
              </div>
            </div>
          )}

          {/* No Content State */}
          {summaries.length === 0 && !isGenerating && (
            <div className="text-center py-8">
              <BookOpen className="h-12 w-12 mx-auto mb-3 text-muted-foreground" />
              <h3 className="font-medium mb-1">No Summaries Yet</h3>
              <p className="text-sm text-muted-foreground mb-4">
                Generate AI-powered chapter summaries to create a reading guide
              </p>
              {!bookText ? (
                <p className="text-xs text-destructive">
                  Book text required for summary generation
                </p>
              ) : (
                <Button onClick={generateSummaries}>
                  <Sparkles className="h-4 w-4 mr-2" />
                  Generate Reading Guide
                </Button>
              )}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  )
}

/**
 * Individual chapter summary card
 */
function ChapterSummaryCard({
  summary,
  isExpanded,
  onToggle
}: {
  summary: ChapterSummary
  isExpanded: boolean
  onToggle: () => void
}) {
  
  const getSentimentColor = (sentiment: string) => {
    switch (sentiment) {
      case 'positive': return 'text-green-600'
      case 'negative': return 'text-red-600'
      default: return 'text-gray-600'
    }
  }

  const getSentimentIcon = (sentiment: string) => {
    switch (sentiment) {
      case 'positive': return 'ðŸ˜Š'
      case 'negative': return 'ðŸ˜¢'
      default: return 'ðŸ˜'
    }
  }

  const getMethodIcon = (method: string) => {
    switch (method) {
      case 'ollama': return <Brain className="h-3 w-3" />
      case 'tfidf': return <Hash className="h-3 w-3" />
      default: return <Zap className="h-3 w-3" />
    }
  }

  const copyChapterSummary = useCallback(() => {
    const text = `Chapter ${summary.chapterNumber}${summary.title ? `: ${summary.title}` : ''}\n\n${summary.summary}\n\nKey Topics: ${summary.keyTopics.join(', ')}\nReading Time: ~${summary.readingTime} minutes`
    
    navigator.clipboard.writeText(text).then(() => {
      toast.success(`Chapter ${summary.chapterNumber} summary copied!`)
    }).catch(() => {
      toast.error('Failed to copy summary')
    })
  }, [summary])

  return (
    <Card className="transition-all duration-200 hover:shadow-md">
      <CardHeader 
        className="cursor-pointer"
        onClick={onToggle}
      >
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <motion.div
              animate={{ rotate: isExpanded ? 90 : 0 }}
              transition={{ duration: 0.2 }}
            >
              <ChevronRight className="h-4 w-4" />
            </motion.div>
            <div>
              <h4 className="font-medium">
                Chapter {summary.chapterNumber}
                {summary.title && <span className="text-muted-foreground">: {summary.title}</span>}
              </h4>
              <div className="flex items-center gap-3 mt-1">
                <div className="flex items-center gap-1 text-xs text-muted-foreground">
                  <Clock className="h-3 w-3" />
                  {summary.readingTime}m
                </div>
                <div className="flex items-center gap-1 text-xs text-muted-foreground">
                  {getMethodIcon(summary.generationMethod)}
                  {summary.generationMethod.toUpperCase()}
                </div>
                <div className={`text-xs ${getSentimentColor(summary.sentiment)}`}>
                  {getSentimentIcon(summary.sentiment)} {summary.sentiment}
                </div>
                <Badge variant="outline" className="text-xs">
                  {(summary.confidence * 100).toFixed(0)}%
                </Badge>
              </div>
            </div>
          </div>
          
          <Button
            variant="ghost"
            size="sm"
            onClick={(e) => {
              e.stopPropagation()
              copyChapterSummary()
            }}
          >
            <Copy className="h-3 w-3" />
          </Button>
        </div>
      </CardHeader>

      <AnimatePresence>
        {isExpanded && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.3 }}
          >
            <CardContent className="pt-0 space-y-4">
              
              {/* Summary Text */}
              <div className="space-y-2">
                <h5 className="text-sm font-medium">Summary</h5>
                <p className="text-sm leading-relaxed">{summary.summary}</p>
              </div>

              <Separator />

              {/* Key Topics */}
              <div className="space-y-2">
                <h5 className="text-sm font-medium">Key Topics</h5>
                <div className="flex flex-wrap gap-1">
                  {summary.keyTopics.map(topic => (
                    <Badge key={topic} variant="outline" className="text-xs">
                      {topic}
                    </Badge>
                  ))}
                </div>
              </div>

              {/* Chapter Stats */}
              <div className="grid grid-cols-3 gap-4 text-xs text-muted-foreground">
                <div>
                  <span className="font-medium">Word Count:</span>
                  <div>{summary.wordCount.toLocaleString()}</div>
                </div>
                <div>
                  <span className="font-medium">Reading Time:</span>
                  <div>~{summary.readingTime} minutes</div>
                </div>
                <div>
                  <span className="font-medium">Confidence:</span>
                  <div>{(summary.confidence * 100).toFixed(0)}%</div>
                </div>
              </div>
            </CardContent>
          </motion.div>
        )}
      </AnimatePresence>
    </Card>
  )
}

/**
 * Check if Ollama is available
 */
async function checkOllamaAvailability(): Promise<boolean> {
  try {
    // Try to reach Ollama API (usually on localhost:11434)
    const response = await fetch('http://localhost:11434/api/tags', {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' }
    })
    return response.ok
  } catch {
    return false
  }
}

/**
 * Split text into chapters (simplified)
 */
function splitTextIntoChapters(text: string): Array<{ number: number, text: string, title?: string }> {
  // Simple chapter detection - look for "Chapter" followed by a number
  const chapterRegex = /(?:^|\n\n+)\s*(?:CHAPTER|Chapter|chapter)\s+([IVXLCDM]+|\d+)(?:\s*[\.\-\:]?\s*(.+?))?(?:\n|$)/gi
  const matches = Array.from(text.matchAll(chapterRegex))
  
  if (matches.length === 0) {
    // If no chapters found, split by approximate length
    const chunkSize = Math.floor(text.length / 10) // Assume ~10 chapters
    const chapters = []
    for (let i = 0; i < 10; i++) {
      const start = i * chunkSize
      const end = Math.min((i + 1) * chunkSize, text.length)
      if (start < text.length) {
        chapters.push({
          number: i + 1,
          text: text.slice(start, end),
          title: `Section ${i + 1}`
        })
      }
    }
    return chapters
  }

  const chapters = []
  for (let i = 0; i < matches.length; i++) {
    const match = matches[i]
    const nextMatch = matches[i + 1]
    
    const start = match.index! + match[0].length
    const end = nextMatch ? nextMatch.index! : text.length
    
    chapters.push({
      number: i + 1,
      text: text.slice(start, end).trim(),
      title: match[2]?.trim() || undefined
    })
  }

  return chapters
}

/**
 * Generate summary using Ollama LLM
 */
async function generateOllamaSummary(
  chapter: { number: number, text: string, title?: string }, 
  chapterNumber: number
): Promise<ChapterSummary> {
  
  // Simplified Ollama API call
  const prompt = `Summarize this chapter in 2-3 sentences. Focus on key events, character developments, and plot progression:\n\n${chapter.text.slice(0, 2000)}...`
  
  try {
    const response = await fetch('http://localhost:11434/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'llama2', // or whatever model is available
        prompt,
        stream: false
      })
    })

    if (!response.ok) throw new Error('Ollama API error')
    
    const data = await response.json()
    const summary = data.response || 'Summary generation failed'

    return {
      chapterNumber,
      title: chapter.title,
      summary,
      keyTopics: extractKeywords(chapter.text).slice(0, 5),
      sentiment: analyzeSentiment(chapter.text),
      wordCount: chapter.text.split(/\s+/).length,
      readingTime: Math.ceil(chapter.text.split(/\s+/).length / 200), // 200 WPM average
      generationMethod: 'ollama',
      confidence: 0.85
    }
  } catch (error) {
    throw new Error('Ollama generation failed')
  }
}

/**
 * Generate summary using TF-IDF keywords
 */
function generateTFIDFSummary(
  chapter: { number: number, text: string, title?: string },
  chapterNumber: number,
  chapterTopics: ChapterTopic[]
): ChapterSummary {
  
  const keywords = extractKeywords(chapter.text)
  const topKeywords = keywords.slice(0, 8)
  
  // Create a simple summary from top keywords
  const summary = `This chapter focuses on ${topKeywords.slice(0, 3).join(', ')}. ` +
    `Key themes include ${topKeywords.slice(3, 6).join(', ')}. ` +
    `Important elements: ${topKeywords.slice(6, 8).join(', ')}.`

  return {
    chapterNumber,
    title: chapter.title,
    summary,
    keyTopics: topKeywords.slice(0, 5),
    sentiment: analyzeSentiment(chapter.text),
    wordCount: chapter.text.split(/\s+/).length,
    readingTime: Math.ceil(chapter.text.split(/\s+/).length / 200),
    generationMethod: 'tfidf',
    confidence: 0.6
  }
}

/**
 * Extract keywords using simple TF-IDF
 */
function extractKeywords(text: string): string[] {
  const words = text.toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 3)

  // Simple stopwords
  const stopwords = new Set(['that', 'with', 'have', 'this', 'will', 'been', 'from', 'they', 'know', 'want', 'been', 'good', 'much', 'some', 'time', 'very', 'when', 'come', 'here', 'just', 'like', 'long', 'make', 'many', 'over', 'such', 'take', 'than', 'them', 'well', 'were'])

  // Count word frequencies
  const wordCounts = new Map<string, number>()
  words.forEach(word => {
    if (!stopwords.has(word)) {
      wordCounts.set(word, (wordCounts.get(word) || 0) + 1)
    }
  })

  // Sort by frequency
  return Array.from(wordCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10)
    .map(([word]) => word)
}

/**
 * Simple sentiment analysis
 */
function analyzeSentiment(text: string): 'positive' | 'negative' | 'neutral' {
  const positiveWords = ['good', 'great', 'excellent', 'wonderful', 'amazing', 'beautiful', 'love', 'happy', 'joy', 'success']
  const negativeWords = ['bad', 'terrible', 'awful', 'horrible', 'hate', 'sad', 'death', 'war', 'evil', 'dark']
  
  const words = text.toLowerCase().split(/\s+/)
  let positiveCount = 0
  let negativeCount = 0
  
  words.forEach(word => {
    if (positiveWords.includes(word)) positiveCount++
    if (negativeWords.includes(word)) negativeCount++
  })
  
  if (positiveCount > negativeCount * 1.2) return 'positive'
  if (negativeCount > positiveCount * 1.2) return 'negative'
  return 'neutral'
}
